---
title: "Implementing automated section control sprayers for optimising pesticide application in orchards"
author: "Clemens Stephany, Christoph Weinmann, Lucas Hoffmann, Adrian Fülle, Jasper Hackling"
date: "6/1/2021"

output:
  html_document:
    toc: true
    toc_float: true
    collapsed: false
    number_sections: true
    theme: readable
bibliography:
  - bib/references.bib
---
  
```{r setup, include=FALSE}
knitr::opts_chunk$set(message = FALSE)
#results = 'hide' ,echo = TRUE,
```


# Abstract (Lucas)

In this project we are looking a prototype of an automated section-control blower 
sprayer (ASCS) which is currently being tested at Competence Centre for Fruit 
Production Lake Constance (Kompetenzzentrum Obstbau Bodensee, KOB) in its first 
season. It is compared on a monetary background to a manual section-control blower 
sprayer (MSCS) which is the current standard technology for spraying pesticides 
in orchards.

The most basic decision to make is whether the reduction of running-costs of the 
ASCS through lower pesticide usage compared to the MSCS are higher than the increased 
initial investment for the more expensive sprayer.

Other factors taken into consideration are the influence the reduction of pesticide 
application has on the biodiversity and water contamination. These factors influence 
the likelihood of the government setting a restriction on the maximum amount of 
pesticide allowed to be applied. In addition, these factors influence the customer 
behavior.

The output of the model generated in this project will be a monetary value for the 
farmer’s profit per hectare, calculated based on the investment costs, running costs, 
damage to the fruits (apples) - calculated by combining applied pesticides (with a 
                                                                            potential limit) and influences of the increased or decreased biodiversity - and 
the customer behavior.

\ 

# Introduction (Jasper)  

Reducing the use of pesticides in agricultural and horticultural production has 
been an important concern of policymakers, NGO, and also farmers for years. Not 
only is a reduction economically favourable on a farm level, but more and more 
negative impacts of the liberal use of agrochemicals on ecosystems have been reported 
recently. In orcharding, efforts have been made to make pesticide application more 
efficient in order to bring down the overall amount applied while still securing 
fruit quality and stable yields. This led to the advent of blower sprayers capable 
of section control. This feature allows the operator to reduce or completely turn 
off the application of pesticides on a part of the total working width when it is 
appropriate. For instance, if a shorter tree comes up in a row of taller trees, 
the operator will manually turn off the topmost section of the blower sprayer to 
prevent pesticide being sprayed past the treetop into the environment. 

While the manually-operated section control sprayer (MSCS) is generally able to 
reduce pesticide application rates while maintaining the effectiveness of the agent 
where it is needed, the strain it puts on the operator is exhausting and requires 
properly trained and experienced personnel. This limits the overall work capacity
of one unit. Furthermore, because of the complex handling, errors are likely to 
occur which diminishes the potential to reduce the ingress of agrochemicals into 
the environment. 

Therefore, a novel technology is currently under development to automate the 
modulation of the section control feature of orchard sprayers. Light detection 
and ranging (LiDAR) sensors are mounted to the sprayer to allow a computer to 
assess the structure of the upcoming trees. This, in turn, enables the machine 
to appropriately adapt the individual sections to the current requirements. Besides 
the immediate relief for the tractor driver, this technology also allows less 
experienced workers to safely spray pesticide in orchards. Therefore, an 
automatically-controlled section control sprayer (ASCS) has a higher work capacity 
than a MSCS, i.e. a larger area can be sprayed in a given amount of time. Apart 
from that, pesticide reduction can be improved due to the higher precision in 
modulating the application rate following the principle of “as little as possible, 
as much as necessary”. 

All in all, the ASCS promises to a more efficient application of pesticide and 
higher work capacity per sprayer, as well as less contamination of the environment 
while maintaining full effectiveness in terms of plant protection. 

## Short introduction to decision analysis

# Intervention

**The two alternatives**  
  
*Decision alternative 1*: Buying an automated section control sprayer for orchards  

* This decision alternative has one main cost and some advantages for the future 
and the environment.  

* The main cost incurred when buying the automated section control sprayer, because 
of the sensors which enable the section control sprayer to regulate the application 
of the pesticides automatically when they are needed.   

* This option can have the advantage to decrease the needed plant protection which 
result in some positive effects on the environment like increasing the biodiversity, 
decreasing the water contamination and decrease the pests and diseases of the apple trees.  

* The benefits were derived from possibly having a bigger harvest and less losses 
due to pest and diseases. They can also derive from not getting sanctioned by 
governmental restrictions concerning about too much application of pesticides.  

\ 

*Decision alternative 2*: Buying a manual section control sprayer for orchards.  

* Within this decision alternative the farmer buys a manual section control sprayer 
where the implementation cost incurred, but less than for the first alternative. 
The farmer must control the application of plant protection by hand and can have 
the disadvantage of applying more pesticide than needed.  

* The benefits are derived from the harvest and selling price, but the advantages 
of not getting sanctioned or increasing the biodiversity and the harvest can`t took place.

\ 

## Description   
Reducing pesticide use: An analysis on the decision whether to implement an automated or manually operated section control sprayer in orchards.

\ 

## Options:  
* Buy automatic section control sprayer
* keeping / buying a manual section control sprayer
* Spray less pesticide with existing machinery 
* Adopt organic farming practices <br/> $\Rightarrow$ Use beneficiaries (beneficial organisms)
* Spray manually <br/> $\Rightarrow$ identify areas which need application <br/> $\Rightarrow$ application amount can be imprecise 

\ 


# Decision maker: farmer   
* Farmer is the main stakeholder who makes the decision whether or not to buy a modern sprayer which is able to minimise pesticide application rates

\ 


# Stakeholders
: (describe further)
* Farmer
+ importance: very high
+ Main Decision maker
+ Operator / User (knowledge about relevant orchards)
+ Budget for purchasing costs
+ profitable longterm?
  
  * Manufacturer
+ importance: (very) low
+ Supplier
+ (takes feedback into account)

* Government
+ importance: medium - high
+ Bund/Länder - Arbeitsgemeinschaft Wasser (LAWA), Landwirtschaftskammer ...
+ Reduction of pesticide residues and unwanted effects
+ taking probes from products, groundwater, biodiversity (short & longterm)

* Consumers
+ importance: low - mid
+ no residues on products
+ inclined to buy farmers products

* Food retailers
+ same as consumers

* Society  
+ importance: low - mid
+ no active influence / Public image <br/> $\Rightarrow$  influencing government decisions (mindset about eg. Biodiversity)

* NGOs
+ importance: mid
+ Greenpeace, newspaper organizations, research centers / institutes
+ influencing society, consumers, government
+ newspaper, magazine article

* Water suppliers
+ importance: mid
+ conservation of healthy water bodies
+ food chains (plankton), fishing grounds, drinking water

* Agro-chemical companies
+ importance: low
+ keeping residues in environment low to prevent restrictive legislation (longterm)
+ BUT less sales of plant protection agents (shortterm)

* Local biodiversity
+ importance: high
+ higher diversity <br/> more pollinators <br/> reduces chance of diseases

* Beekeepers
+ importance: low - mid
+ less potential harm to bees


\ 

# Data acquistion (Christoph)  

## (Sources of) information:
* Farmers
+ knowledge of the farm, knowledge of problems during application 
* Manufacturer (Currently developing a prototype)
+ Cost and capabilities of an automatic section control sprayer
* Landwirtschaftskammer NRW
+ Potential subsidisation of automatic section control sprayer
+ Political foreshadowing of future legislations
* (commercial) Beekeepers
+ How much of an problem are pesticides
* Consumers
+ Assess the importance/conception of reduced pesticide application to the consumer 

\ 

## Expert knowledge (Nils)  

For the decision-relevant questions, we consulted various stakeholders as experts 
for our model. We consulted several experimental managers from different apple 
growing regions in Germany, Leaders and technical assistants from the area of 
plant health, plant protection and production technology of the Competence Centre 
for Fruit Production Lake Constance, as well as fruit grower from the Lake 
Constance region.  

\ 

## Calibration training (Christoph)  

For a decision analysis it is important to known how valuable the given estimates 
are because it need to be based on comprehensive and reliable data. Therefore, 
calibration training is applied.  

Calibration is a process to find out and document how the deviation of measuring 
device is. Due to Calibration training the affective answering behavior is reduced 
and it helps to improve the given estimates. It can also help to know your 
uncertainties and to train to give good estimates.  

In this case experts are used as measuring device for good estimates. The answers 
are normally linked to various cognitive biases and normally lead to an overconfidence 
of the experts about their estimates.  

To reduce this, a series of basic questions is used. In the first part of the 
calibration training the persons to be calibrated need to answer questions where 
the correct answer must be within a range. In the second part they need to answer 
yes or no questions and they need to estimate their confidence about the given 
answers. after answering the basic questions, they get the feedback about the 
given answers. This led to a reduction of overconfidence.  

After the calibration training, they were asked about estimates to all inputs for 
the model with a 90% confidence interval.  

\  

## Allocation of resources:  
* Money
+ Overheads
+ Overheads        
+ Running costs 
* Labour 
+ Conducting actual tasks 
+ Acquiring know-how
* Pollinators  

\ 

# Problems:    
* Some common agrochemicals will be banned in the near future for various reasons
+ Overuse causes problems 
+ Public opinion is getting worse   
* Excessive use of pesticides can cause unwanted effects (e.g. resistances)  
* Agrochemicals are costly supplies <br/> $\Rightarrow$ reduction is welcome  

## Obstacles:  
* Costs of investment
* Learning curve for running the equipment 
* compatibility with current machinery

## Uncertainties:  
* Potential reduction of pesticides using an automatic section controlled sprayer
+ Especially the reduction of excessive pesticides
* Common application rates of pesticides in orchards
* Potential Cost of an automatic section controlled sprayer
* Changing climate influencing the frequency of pesticides application
* Increased bee survival rate (as there still are pesticides, just less)
* Added value through increased bee survival and thus increasing pollination
* Governmental interest in pesticides reduction
* Image of a farmer trying to reduce pesticides but still using them
* Maintenance cost of an more complicated and sensitive system


# Flow chart of our model {.tabset}
```{r, include=FALSE}
# Using diagrammeR package
library(decisionSupport)
library(DiagrammeR)
library(DiagrammeRsvg)
library(rsvg)
library(tidyverse)
```


## Plot
```{r echo=FALSE}

model_flow_chart <- grViz("

digraph {
  
  # Add general information which counts for everything!!!
  
  # ---------
  # Change flow chart orientation (top down: 'TD'; left to right: 'LR' 
  rankdir = 'LR'
  
  # Add graph statements 
  graph [#label = 'Initial Model',
         labelloc = t,
         fontsize = 45,
         ranksep=2,
         nodesep=1]
  
  # Add node statements
  node [fontname = Arial,
        fontcolor = black,
        color = darkslategray,
        penwidth = 1]
  
  # Add edge statements
  edge [fontsize=30,
        penwidth=2,
        fontname=Arial]
  # ---------  
  
  # ---------  
  # create 'ranks' (basically nodes) for arranging nodes later on
  rank1 [style=invis]
  rank2 [style=invis]
  rank3 [style=invis]
  rank4 [style=invis]
  rank5 [style=invis]
  
  # make invisible (white) links between them
  rank1->rank2->rank3->rank4->rank5 [color=white]
  # ---------  
  
  # ---------  
  # Add specific statements for node group {Intervention & Alternatives} 
  node [shape = box,
        fontsize = 30,
        fixedsize = true,
        width = 3.6,
        height = 1.5]

    Ascs [label = 'Automated section \n control sprayer'];
    Al1 [label = 'Manual section \n control sprayer'];
  # ---------
  
  
  
  # Add specific statements for node group {Pesticides & Cost} 
  # --------- 
  node [shape = box,
        fontsize = 28,
        fixedsize = true,
        width = 2.8,
        height = 0.9]
  
  Pe [label = 'Pesticides'];
  Co [label = 'Cost']
  
  Cu [label = 'Customers'];          
  Di [label = 'Plant damage'];
  Bio [label = 'Biodiversity'];
  WC [label = 'Water \n contamination'];
  
  FS [label = 'Fruit sales'];
  GC [label = 'Government \n concerns'];
  
  FP [label = 'Farmers profit']
  
  # ---------  
  
  
  # Add edge statements for negative connection (arrows) and add the connections
  # ---------  
  edge [label = '-    ',
        fontcolor = 'red',
        color = 'red']
  {Ascs Al1} -> Pe #[headport = w, tailport = e]
  GC -> Pe
  Pe->Bio #[headport = w]
  Pe-> Di 
  Bio->{Di GC}
  WC->{Bio Cu}
  Di->FS
  Co->FP
  # ---------  
  
  # Add edge statements for positive connection (arrows) and add the connections
  # ---------  
  edge [label = '+',
        fontcolor = 'forestgreen',
        color = 'forestgreen']
  
  {Ascs Al1}->Co #[headport = w, tailport = s]
  Pe-> WC  #[headport = w, tailport = n]
  Pe-> Co
  FS->FP 
  WC->GC 
  Bio-> Cu
#  Di -> Pe
  Cu->FS
  # ---------  
  
  # ---------  
  # sorting the nodes per rank
  
  {
    Ascs -> Al1 -> rank1 [style=invis];
    rank=same;
    rankdir=TD;
  }
  
  {
    Co -> Pe -> GC -> rank2 [style=invis];
    rank=same;
    rankdir=TD;
  }
  
  {
    Di -> Bio -> WC -> rank3 [style=invis];
    rank=same;
    rankdir=TD;
  }
  
  {
    Cu -> FS -> rank4 [style=invis];
    rank=same;
    rankdir=TD;
  }
 
#   {
#     rank5 -> FS [style=invis];
#     rank=same;
#     rankdir=DT;
#   }
#   
  # ---------  
  
}")

# Plot flow chart 
model_flow_chart

# Export flow chart as .png files; save in "images" folder 
rsvg_png(charToRaw(export_svg(model_flow_chart)), "images/flow-chart.png") 


```


## Code
```{r, eval=FALSE}

model_flow_chart <- grViz("

digraph {
  
  # Add general information which counts for everything!!!
  
  # ---------
  # Change flow chart orientation (top down: 'TD'; left to right: 'LR' 
  rankdir = 'LR'
  
  # Add graph statements 
  graph [#label = 'Initial Model',
         labelloc = t,
         fontsize = 45,
         ranksep=2,
         nodesep=1]
  
  # Add node statements
  node [fontname = Arial,
        fontcolor = black,
        color = darkslategray,
        penwidth = 1]
  
  # Add edge statements
  edge [fontsize=30,
        penwidth=2,
        fontname=Arial]
  # ---------  
  
  # ---------  
  # create 'ranks' (basically nodes) for arranging nodes later on
  rank1 [style=invis]
  rank2 [style=invis]
  rank3 [style=invis]
  rank4 [style=invis]
  rank5 [style=invis]
  
  # make invisible (white) links between them
  rank1->rank2->rank3->rank4->rank5 [color=white]
  # ---------  
  
  # ---------  
  # Add specific statements for node group {Intervention & Alternatives} 
  node [shape = box,
        fontsize = 30,
        fixedsize = true,
        width = 3.6,
        height = 1.5]

    Ascs [label = 'Automated section \n control sprayer'];
    Al1 [label = 'Manual section \n control sprayer'];
  # ---------
  
  
  
  # Add specific statements for node group {Pesticides & Cost} 
  # --------- 
  node [shape = box,
        fontsize = 28,
        fixedsize = true,
        width = 2.8,
        height = 0.9]
  
  Pe [label = 'Pesticides'];
  Co [label = 'Cost']
  
  Cu [label = 'Customers'];          
  Di [label = 'Plant damage'];
  Bio [label = 'Biodiversity'];
  WC [label = 'Water \n contamination'];
  
  FS [label = 'Fruit sales'];
  GC [label = 'Government \n concerns'];
  
  FP [label = 'Farmers profit']
  
  # ---------  
  
  
  # Add edge statements for negative connection (arrows) and add the connections
  # ---------  
  edge [label = '-    ',
        fontcolor = 'red',
        color = 'red']
  {Ascs Al1} -> Pe #[headport = w, tailport = e]
  GC -> Pe
  Pe->Bio #[headport = w]
  Pe-> Di 
  Bio->{Di GC}
  WC->{Bio Cu}
  Di->FS
  Co->FP
  # ---------  
  
  # Add edge statements for positive connection (arrows) and add the connections
  # ---------  
  edge [label = '+',
        fontcolor = 'forestgreen',
        color = 'forestgreen']
  
  {Ascs Al1}->Co #[headport = w, tailport = s]
  Pe-> WC  #[headport = w, tailport = n]
  Pe-> Co
  FS->FP 
  WC->GC 
  Bio-> Cu
#  Di -> Pe
  Cu->FS
  # ---------  
  
  # ---------  
  # sorting the nodes per rank
  
  {
    Ascs -> Al1 -> rank1 [style=invis];
    rank=same;
    rankdir=TD;
  }
  
  {
    Co -> Pe -> GC -> rank2 [style=invis];
    rank=same;
    rankdir=TD;
  }
  
  {
    Di -> Bio -> WC -> rank3 [style=invis];
    rank=same;
    rankdir=TD;
  }
  
  {
    Cu -> FS -> rank4 [style=invis];
    rank=same;
    rankdir=TD;
  }
 
#   {
#     rank5 -> FS [style=invis];
#     rank=same;
#     rankdir=DT;
#   }
#   
  # ---------  
  
}")



```

# Model {.tabset}

## Model
```{r}

# Importing and adjusting input table 
input_table <- read.csv("data/input_data_03.csv", sep = ";", dec = ",", stringsAsFactors = FALSE)
input_table <- drop_na(input_table, c("lower","upper"))
input_table <- filter(input_table, !variable == "initial_aut_cost", !variable == "pesticide_quantity") # !variable == "initial_aut_cost", 
input_table <- input_table[ order(input_table$distribution, input_table$variable), ]
write.csv(input_table, "data/final/inputs.csv", row.names = FALSE)
input_table <- read.csv("data/final/inputs.csv", stringsAsFactors = FALSE)


ascs_decision_model <- function(x, varnames){
  
  # table for iterative impacted variables 
  auxiliary_table <- data.frame(year = c(1:n_years),
                                pest_quant_man = rep(0.,n_years),
                                pest_quant_aut = rep(0.,n_years),
                                rel_water_cont_man = rep(0.,n_years),
                                rel_water_cont_aut = rep(0.,n_years),
                                rel_bio_man = rep(0.,n_years),
                                rel_bio_aut = rep(0.,n_years),
                                plant_dmg_pot_man = rep(0.,n_years),
                                plant_dmg_pot_aut = rep(0.,n_years),
                                actual_plant_dmg_man = rep(0.,n_years),
                                actual_plant_dmg_aut = rep(0.,n_years),
                                gov_inter_chance_man = rep(0.,n_years),
                                gov_inter_chance_aut = rep(0.,n_years),
                                gov_inter_happened_man = rep(0,n_years),
                                gov_inter_happened_aut = rep(0,n_years),
                                gov_reaction = rep(0,n_years)
  )
  
  
  for (y in 1:n_years) {
    
    if (y == 1) { # first year
      # fix for one run
      ## generating a vector for the government reaction delay 
      lower <- input_table[input_table$variable == "government_reaction_time", "lower"]
      upper <- input_table[input_table$variable == "government_reaction_time", "upper"]
      auxiliary_table$gov_reaction <- round(runif(n_years,lower,upper))
      
      # general chance that government intervenes
      # in year 1 this is covered by (pre-)assumptions
      ## will be affected by biodiversity and water contamination later on 
      auxiliary_table$gov_inter_chance_man[y] <- government_intervention_chance 
      auxiliary_table$gov_inter_chance_aut[y] <- auxiliary_table$gov_inter_chance_man[y]
      # chance event of government intervention takes only place if the reaction
      # delay is inside our n_years boundaries 
      if ((y + auxiliary_table$gov_reaction[y]) <= n_years) {
        auxiliary_table$gov_inter_happened_man[y + auxiliary_table$gov_reaction[y]] <- chance_event(auxiliary_table$gov_inter_chance_man[y], 1, 0)
        auxiliary_table$gov_inter_happened_aut[y + auxiliary_table$gov_reaction[y]] <- chance_event(auxiliary_table$gov_inter_chance_aut[y], 1, 0)
      }
      # influence factor from pesticides on water contamination ## fix per run
      pest_cont_fac <- vv(pesticide_on_water_contamination_factor, var_CV, 1)
      # influence factor from pesticides on biodiversity ## fix per run
      pest_bio_fac <- vv(pesticide_on_biodiversity_factor, var_CV, 1)
      # influence factor from water contamination on biodiversity ## fix per run
      cont_bio_fac <- vv(water_contamination_on_biodiversity_factor, var_CV, 1)
      # pesticide reduction factor when using the automated sprayer
      pest_red_fac <- pesticide_reduction_auto
      
      # potential plant damage vector for n_years
      # its the same for both decisions 
      ## will be affected by biodiversity later on 
      auxiliary_table$plant_dmg_pot_man <- vv(potential_plant_damage, potential_plant_damage_CV, n_years)
      auxiliary_table$plant_dmg_pot_aut <- auxiliary_table$plant_dmg_pot_man
      
      # manual correlation between pesticide quantity and potential plant damage
      ## the farmer tries to assess how much plant damage there will be and sets
      ## the applied pest quantity accordingly      
      lower <- input_table[input_table$variable == "farmers_pesticide_quantity_miscalculation", "lower"]
      upper <- input_table[input_table$variable == "farmers_pesticide_quantity_miscalculation", "upper"]
      auxiliary_table$pest_quant_man <- auxiliary_table$plant_dmg_pot_man * rposnorm90ci(n_years, lower = lower, upper = upper)
      auxiliary_table$pest_quant_aut <- auxiliary_table$pest_quant_man * pest_red_fac
      
      # water contamination and biodiversity are 1 in the first year ("status quo")
      auxiliary_table$rel_water_cont_man[y] <- 1 
      auxiliary_table$rel_water_cont_aut[y] <- 1 
      
      auxiliary_table$rel_bio_man[y] <- 1
      auxiliary_table$rel_bio_aut[y] <- 1
      
      # actual plant damage 
      ## actual plant damage = potential plant damage - quantity sprayed
      ## the automated needs less spraying to counter the same amount
      ## of potential plant damage (/ pest_red_fac)
      actual_plant_dmg_man <- auxiliary_table$plant_dmg_pot_man[y] - auxiliary_table$pest_quant_man[y]
      auxiliary_table$actual_plant_dmg_man[y] <- ifelse(actual_plant_dmg_man < 0,
                                                        0,
                                                        actual_plant_dmg_man)
      
      actual_plant_dmg_aut <- auxiliary_table$plant_dmg_pot_aut[y] - auxiliary_table$pest_quant_aut[y] / pest_red_fac
      auxiliary_table$actual_plant_dmg_aut[y] <- ifelse(actual_plant_dmg_aut < 0,
                                                        0,
                                                        actual_plant_dmg_aut)
      
    }else  {  # ongoing years (year 2 - n_years) 
      ## the values change per year so the influence changes as well
      # government intervention chance
      ## general chance affected by biodiversity and water contamination 
      auxiliary_table$gov_inter_chance_man[y] <- auxiliary_table$gov_inter_chance_man[y-1] +
        ( ((1 - auxiliary_table$rel_bio_man[y-1]) * biodiversity_on_gov_concern) + 
            ((auxiliary_table$rel_water_cont_man[y-1] - 1) * water_contamination_on_gov_concern))
      
      auxiliary_table$gov_inter_chance_aut[y] <- auxiliary_table$gov_inter_chance_aut[y-1] +
        ( ((1 - auxiliary_table$rel_bio_aut[y-1]) * biodiversity_on_gov_concern) + 
            ((auxiliary_table$rel_water_cont_aut[y-1] - 1) * water_contamination_on_gov_concern))
      
      # checking if the chance is really between 0 and 1 so the chance_event function works
      auxiliary_table$gov_inter_chance_man[y] <- ifelse(auxiliary_table$gov_inter_chance_man[y] <= 0,
                                                        0,
                                                        ifelse(auxiliary_table$gov_inter_chance_man[y] >= 1,
                                                               1,
                                                               auxiliary_table$gov_inter_chance_man[y]))
      auxiliary_table$gov_inter_chance_aut[y] <- ifelse(auxiliary_table$gov_inter_chance_aut[y] <= 0,
                                                        0,
                                                        ifelse(auxiliary_table$gov_inter_chance_aut[y] >= 1,
                                                               1,
                                                               auxiliary_table$gov_inter_chance_aut[y]))
      
      
      # chance_event function 
      ## only applies if the value for the intervention delay + the current year is still inside the n_years boarder &
      ### there was no intervention in the previous years
      ### there was no intervention in the relevant year already
      if(auxiliary_table$gov_inter_happened_man[y-1] == 0){
        if(y + auxiliary_table$gov_reaction[y] <= n_years){
          if(auxiliary_table$gov_inter_happened_man[y + auxiliary_table$gov_reaction[y]] == 0){
            auxiliary_table$gov_inter_happened_man[y + auxiliary_table$gov_reaction[y]] <- chance_event(auxiliary_table$gov_inter_chance_man[y], 1, 0)
          }
        }
      }else{
        auxiliary_table$gov_inter_happened_man[y] <- 1
      }
      
      if(auxiliary_table$gov_inter_happened_aut[y-1] == 0){
        if(y + auxiliary_table$gov_reaction[y] <= n_years){
          if(auxiliary_table$gov_inter_happened_aut[y + auxiliary_table$gov_reaction[y]] == 0){
            auxiliary_table$gov_inter_happened_aut[y + auxiliary_table$gov_reaction[y]] <- chance_event(auxiliary_table$gov_inter_chance_aut[y], 1, 0)
          }
        }  
      }else{
        auxiliary_table$gov_inter_happened_aut[y] <- 1
      }
      
      
      # water contamination 
      ## assuming that the pesticide quantity influences the water contamination by pest_cont_fac
      auxiliary_table$rel_water_cont_man[y] <- auxiliary_table$rel_water_cont_man[y-1] +
        ((auxiliary_table$pest_quant_man[y-1] - 1) * pest_cont_fac)
      auxiliary_table$rel_water_cont_aut[y] <- auxiliary_table$rel_water_cont_aut[y-1] +
        ((auxiliary_table$pest_quant_aut[y-1] - 1) * pest_cont_fac)
      
      # biodiversity 
      ## assuming that the pesticides influences the biodiversity by pest_bio_fac
      ## assuming that the water contamination influences the biodiversity by cont_bio_fac
      auxiliary_table$rel_bio_man[y] <- auxiliary_table$rel_bio_man[y-1] +
        ((1 - auxiliary_table$pest_quant_man[y-1]) * pest_bio_fac) + ((1 - auxiliary_table$rel_water_cont_man[y-1]) * cont_bio_fac)
      
      auxiliary_table$rel_bio_aut[y] <- auxiliary_table$rel_bio_aut[y-1] +
        ((1 - auxiliary_table$pest_quant_aut[y-1]) * pest_bio_fac) + ((1 - auxiliary_table$rel_water_cont_aut[y-1]) * cont_bio_fac)
      
      # potential plant damage
      ## effected by biodiversity
      auxiliary_table$plant_dmg_pot_man[y] <- auxiliary_table$plant_dmg_pot_man[y] +
        auxiliary_table$plant_dmg_pot_man[y] * (1 -  auxiliary_table$rel_bio_man[y])
      
      auxiliary_table$plant_dmg_pot_aut[y] <- auxiliary_table$plant_dmg_pot_aut[y] +
        auxiliary_table$plant_dmg_pot_aut[y] * (1 -  auxiliary_table$rel_bio_aut[y])
      
      # pesticide quantity
      ## effected by biodiversity
      auxiliary_table$pest_quant_man[y] <- auxiliary_table$pest_quant_man[y] +
        auxiliary_table$pest_quant_man[y] * (1 - auxiliary_table$rel_bio_man[y])
      auxiliary_table$pest_quant_aut[y] <- (auxiliary_table$pest_quant_aut[y] +
        auxiliary_table$pest_quant_aut[y] * (1 - auxiliary_table$rel_bio_aut[y]))
      
      # influence of chance_event
      auxiliary_table$pest_quant_man[y] <- ifelse(auxiliary_table$gov_inter_happened_man[y] == 0,
                                                  auxiliary_table$pest_quant_man[y],
                                                  ifelse(auxiliary_table$pest_quant_man[y] > government_pesticide_quantity,
                                                         government_pesticide_quantity,
                                                         auxiliary_table$pest_quant_man[y]))
      
      auxiliary_table$pest_quant_aut[y] <- ifelse(auxiliary_table$gov_inter_happened_aut[y] == 0,
                                                  auxiliary_table$pest_quant_aut[y],
                                                  ifelse(auxiliary_table$pest_quant_aut[y] > government_pesticide_quantity,
                                                         government_pesticide_quantity,
                                                         auxiliary_table$pest_quant_aut[y]))
      
      # actual plant damage 
      ## potential plant damage - pesticide quantity 
      actual_plant_dmg_man <- auxiliary_table$plant_dmg_pot_man[y] - auxiliary_table$pest_quant_man[y]
      auxiliary_table$actual_plant_dmg_man[y] <- ifelse(actual_plant_dmg_man < 0,
                                                        0,
                                                        actual_plant_dmg_man)
      
      actual_plant_dmg_aut <- auxiliary_table$plant_dmg_pot_aut[y] - auxiliary_table$pest_quant_aut[y]  / pest_red_fac
      auxiliary_table$actual_plant_dmg_aut[y] <- ifelse(actual_plant_dmg_aut < 0,
                                                        0,
                                                        actual_plant_dmg_aut)
    }
    
  }
  
  # Debugging
  # print(auxiliary_table)
  
  
  # yields prizes are varying depending on the years and the plant damage
  yield_t_ha <- vv(yield, var_CV, n_years)
  yield_t_ha_man <- yield_t_ha * (1 - auxiliary_table$actual_plant_dmg_man)
  yield_t_ha_aut <- yield_t_ha * (1 - auxiliary_table$actual_plant_dmg_aut)
  
  # market prizes are varying over the years
  market_price_e_t <- vv(market_price, var_CV, n_years)
  
  # fruit sales depend on yield and market price
  fruit_sales_e_ha_man <- yield_t_ha_man * market_price_e_t
  fruit_sales_e_ha_aut <- yield_t_ha_aut * market_price_e_t
  
  # costs for pesticides per ha and decision
  pest_cost_ha_const <- vv( pesticide_cost, var_CV, n_years )
  pest_cost_ha_man <- pest_cost_ha_const * auxiliary_table$pest_quant_man
  pest_cost_ha_aut <- pest_cost_ha_const * auxiliary_table$pest_quant_aut
  
  # machine costs are applied only once so n = 1
  machine_cost_man <- c( initial_man_cost, rep( 0, (n_years-1) ) )
  machine_cost_aut <- machine_cost_man + c( initial_upg_cost, rep( 0, (n_years-1) ) )
  
  # customers influence
  ## influenced by water contamination and biodiversity on customers buying behaviour
  customers_man <- rep(customer_on_fruitsales, n_years) +
    (auxiliary_table$rel_bio_man - 1) * biodiversity_on_customer +
    (1 - auxiliary_table$rel_water_cont_man) * water_contamination_on_customer
  customers_aut <- rep(customer_on_fruitsales, n_years) +
    (auxiliary_table$rel_bio_aut - 1) * biodiversity_on_customer +
    (1 - auxiliary_table$rel_water_cont_aut) * water_contamination_on_customer
  
  # profit - depends an the fruit sales and the pesticide costs per hectare 
  ## resulting profit gets multiplied by the number of hectares (area_per_machine)
  ## for the automated option the machine upgrade cost get subtracted 
  farmers_profit_man = (fruit_sales_e_ha_man * customers_man - pest_cost_ha_man) * area_per_machine - machine_cost_man
  farmers_profit_aut = (fruit_sales_e_ha_aut * customers_aut - pest_cost_ha_aut) * area_per_machine - machine_cost_aut
  
  # NPV - the value of money in the future gets discounted
  ## 2 - 5 % since our farmers are likely to invest
  NPV_aut = discount(farmers_profit_aut, discount_rate, calculate_NPV = TRUE)
  NPV_man = discount(farmers_profit_man, discount_rate, calculate_NPV = TRUE)
  
  # debugging print  (only with small number of runs)
  #print(auxiliary_table)
  #print(farmers_profit_aut)
  #print(farmers_profit_man)
  return(list(Interv_NPV = NPV_aut,
              NO_Interv_NPV = NPV_man,
              NPV_decision_do = NPV_aut - NPV_man,
              Cashflow_decision_do = farmers_profit_aut - farmers_profit_man))
}


```

## Monte Carlo Simulation
```{r}

## Perform a Monte Carlo simulation 
mcSimulation_results <- decisionSupport::mcSimulation(
  estimate = as.estimate(input_table),
  model_function = ascs_decision_model,
  numberOfModelRuns = 5,
  functionSyntax = "plainNames"
)

# Here we subset the outputs from the mcSimulation function (y) by selecting the correct variables
# choose this carefully and be sure to run the multi_EVPI only on the variables that the you want
mcSimulation_table <- data.frame(mcSimulation_results$x, mcSimulation_results$y[1:3])

evpi <- multi_EVPI(mc = mcSimulation_table, first_out_var = "Interv_NPV")

```

# Results {.tabset}

## Comparison
<details><summary>Expand code</summary>
```{r}
#, eval = FALSE
## Plot Net Present Value (NPV) distributions 
compare_decisions <- decisionSupport::plot_distributions(mcSimulation_object = mcSimulation_results, 
                                    vars = c("Interv_NPV", "NO_Interv_NPV"),
                                    method = 'smooth_simple_overlay', 
                                    base_size = 7)

# ggsave(filename = "images/compare_decisions.png", plot = compare_decisions, width = 5, height = 3)

compare_boxplot <- decisionSupport::plot_distributions(mcSimulation_object = mcSimulation_results, 
                                    vars = c("Interv_NPV",
                                             "NO_Interv_NPV"),
                                    method = 'boxplot')
# NPV_distribution <- 
decision_do <- decisionSupport::plot_distributions(mcSimulation_object = mcSimulation_results, 
                                    vars = "NPV_decision_do",
                                    method = 'boxplot_density')

# ggsave(filename = "images/NPV_distribution.png", plot = NPV_distribution, width = 5, height = 3)
```
</details>
```{r echo = FALSE}
compare_decisions
compare_boxplot
decision_do
```

## Cashflow
<details><summary>Expand code</summary>
```{r}
cashflow <- plot_cashflow(mcSimulation_object = mcSimulation_results, cashflow_var_name = "Cashflow_decision_do")

```
</details>
```{r echo = FALSE}
cashflow
```

## PLS
<details><summary>Expand code</summary>
```{r}
## Projection to Latent Structures (PLS) analysis 
pls_result <- plsr.mcSimulation(object = mcSimulation_results,
                                resultName = names(mcSimulation_results$y)[3], ncomp = 1)
pls <- plot_pls(pls_result, input_table = data.frame(variable = input_table$variable, label = input_table$label), threshold = 0.9)

#ggsave(filename = "images/pls.png", plot = pls, width = 6, height = 5)

```
</details>
```{r echo = FALSE}
pls
```

## EVPI
<details><summary>Expand code</summary>
```{r}

## Value of information (VoI) analysis 
evpi_plot <- plot_evpi(evpi, decision_vars = "NPV_decision_do")

```
</details>
```{r echo = FALSE}
pls
evpi_plot
```

## Compound figure {.active}
<details><summary>Expand code</summary>
```{r}
compound_fig <- compound_figure(mcSimulation_object = mcSimulation_results, 
                                input_table = input_table,
                                plsrResults = pls_result, 
                                EVPIresults = evpi,
                                decision_var_name = "NPV_decision_do", 
                                cashflow_var_name = "Cashflow_decision_do", 
                                base_size = 7) 



```
</details>
```{r echo=FALSE}

# ggsave(filename = "images/compound_figure.png", plot = compound_fig, width = 7, height = 5)

compound_fig

plot_cashflow_new <- function (mcSimulation_object, cashflow_var_name, x_axis_name = "Timeline of intervention", 
                               y_axis_name = "Cashflow", legend_name = "Quantiles (%)", 
                               legend_labels = c("5 to 95", "25 to 75", "median"), 
                               color_25_75 = "grey40", color_5_95 = "grey70", 
                               color_median = "blue", facet_labels = cashflow_var_name, 
                               base_size = 11, ...) 
{
  assertthat::assert_that(class(mcSimulation_object)[[1]] == 
                            "mcSimulation", msg = "mcSimulation_object is not class 'mcSimulation', please provide a valid object. This does not appear to have been generated with 'mcSimulation' function.")
  data <- data.frame(mcSimulation_object$y, mcSimulation_object$x)
  assertthat::assert_that(is.character(cashflow_var_name), 
                          msg = "cashflow_var_name is not a character string.")
  assertthat::assert_that(all(!stringr::str_detect(cashflow_var_name, 
                                                   pattern = "[:digit:]{1,}")), msg = "cashflow_var_name contains numbers. Consider renaming your cashflow variables in the model function")
  assertthat::assert_that(is.character(x_axis_name), msg = "x_axis_name is not a character string.")
  assertthat::assert_that(is.character(y_axis_name), msg = "y_axis_name is not a character string.")
  assertthat::assert_that(is.character(color_25_75), msg = "color_25_75 is not a character string.")
  assertthat::assert_that(is.character(color_5_95), msg = "color_5_95 is not a character string.")
  assertthat::assert_that(is.character(color_median), msg = "color_median is not a character string.")
  assertthat::assert_that(color_25_75 %in% grDevices::colors(), 
                          msg = "Please choose a color name for color_25_75 from the grDevices colors.")
  assertthat::assert_that(color_5_95 %in% grDevices::colors(), 
                          msg = "Please choose a color name for color_5_95 from the grDevices colors.")
  assertthat::assert_that(color_median %in% grDevices::colors(), 
                          msg = "Please choose a color name for color_median from the grDevices colors.")
  assertthat::assert_that(any(substr(names(data), 1, nchar(cashflow_var_name)) %in% 
                                cashflow_var_name), msg = "There are no variables that start with the same name as cashflow_var_name in your data.")
  if (any(is.na(data))) {
    warning(paste("Some data included \"NA\" and", 
                  table(is.na(data))[2], "rows were removed."))
    data <- data[stats::complete.cases(data), ]
  }
  subset_data <- data %>% dplyr::select(dplyr::starts_with(cashflow_var_name)) %>% 
    tidyr::pivot_longer(dplyr::starts_with(cashflow_var_name))
  years_position <- stringr::str_locate(subset_data$name, pattern = "[:digit:]{1,}")
  subset_data <- subset_data %>% dplyr::mutate(x_scale = as.numeric(substr(subset_data$name, 
                                                                           years_position[, 1], years_position[, 2])), decision_option = as.character(substr(subset_data$name, 
                                                                                                                                                             1, (years_position[, 1] - 1))))
  
  
  
  
  subset_data$x_scale[subset_data$name == "Cashflow_decision_do10"] <- rep(10,100)
  
  
  
  
  
  summary_subset_data <- suppressMessages(subset_data %>% dplyr::group_by(decision_option, 
                                                                          x_scale) %>% dplyr::summarize(p5 = quantile(value, 0.05), 
                                                                                                        p25 = quantile(value, 0.25), p50 = quantile(value, 0.5), 
                                                                                                        p75 = quantile(value, 0.75), p95 = quantile(value, 0.95)))
  ggplot2::ggplot(summary_subset_data, ggplot2::aes(x_scale)) + 
    ggplot2::geom_ribbon(ggplot2::aes(ymin = p5, ymax = p95, 
                                      fill = legend_labels[1])) + ggplot2::geom_ribbon(ggplot2::aes(ymin = p25, 
                                                                                                    ymax = p75, fill = legend_labels[2])) + ggplot2::geom_line(ggplot2::aes(y = p50, 
                                                                                                                                                                            color = legend_labels[3])) + ggplot2::geom_line(ggplot2::aes(y = 0)) + 
    ggplot2::scale_x_continuous(expand = c(0, 0)) + ggplot2::scale_y_continuous(labels = scales::comma) + 
    ggplot2::scale_fill_manual(values = c(color_25_75, color_5_95)) + 
    ggplot2::scale_color_manual(values = color_median) + 
    ggplot2::guides(fill = ggplot2::guide_legend(reverse = T, 
                                                 order = 1)) + ggplot2::labs(x = x_axis_name, y = y_axis_name, 
                                                                             fill = legend_name, color = "") + ggplot2::facet_wrap(~factor(decision_option, 
                                                                                                                                           labels = facet_labels)) + ggplot2::theme_bw(base_size = base_size) + 
    ggplot2::theme(legend.margin = ggplot2::margin(-0.75, 
                                                   0, 0, 0, unit = "cm"), strip.background = ggplot2::element_blank(), 
                   ...)
}
```



``` {r, include=FALSE}
# data <- mcSimulation_results$y[!(names(mcSimulation_results$y) %in% c("Interv_NPV", "NO_Interv_NPV", "NPV_decision_do"))]
# cashflow_var_name = "Cashflow_decision_do"
# 
# 
# subset_data <- data %>% dplyr::select(dplyr::starts_with(cashflow_var_name)) %>% 
#   tidyr::pivot_longer(dplyr::starts_with(cashflow_var_name))
# 
# years_position <- stringr::str_locate(subset_data$name, pattern = "[0-9]")
# 
# subset_data <- subset_data %>% dplyr::mutate(x_scale = as.numeric(substr(subset_data$name,
#                                                                          years_position[, 1],
#                                                                          years_position[, 2])),
#                                              decision_option = as.character(substr(subset_data$name, 1, (years_position[, 1] - 1))))
# 
# ############### hier liegt der fehler ... das pattern sucht nur nach einer einzelnen zahl
# ############### Cashflow_decision_do10 wird mit Cashflow_decision_do1 gleichgesetzt
# subset_data$x_scale[subset_data$name == "Cashflow_decision_do10"] <- rep(10,100)
# 
# summary_subset_data <- subset_data %>%
#   dplyr::group_by(decision_option, x_scale) %>%
#   dplyr::summarize(p5 = quantile(value, 0.05),
#                    p25 = quantile(value, 0.25),
#                    p50 = quantile(value, 0.5),
#                    p75 = quantile(value, 0.75),
#                    p95 = quantile(value, 0.95))
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# plot_cashflow_new <- function (mcSimulation_object, cashflow_var_name, x_axis_name = "Timeline of intervention", 
#                                y_axis_name = "Cashflow", legend_name = "Quantiles (%)", 
#                                legend_labels = c("5 to 95", "25 to 75", "median"), 
#                                color_25_75 = "grey40", color_5_95 = "grey70", 
#                                color_median = "blue", facet_labels = cashflow_var_name, 
#                                base_size = 11, ...) 
# {
#   assertthat::assert_that(class(mcSimulation_object)[[1]] == 
#                             "mcSimulation", msg = "mcSimulation_object is not class 'mcSimulation', please provide a valid object. This does not appear to have been generated with 'mcSimulation' function.")
#   data <- data.frame(mcSimulation_object$y, mcSimulation_object$x)
#   assertthat::assert_that(is.character(cashflow_var_name), 
#                           msg = "cashflow_var_name is not a character string.")
#   assertthat::assert_that(all(!stringr::str_detect(cashflow_var_name, 
#                                                    pattern = "[:digit:]")), msg = "cashflow_var_name contains numbers. Consider renaming your cashflow variables in the model function")
#   assertthat::assert_that(is.character(x_axis_name), msg = "x_axis_name is not a character string.")
#   assertthat::assert_that(is.character(y_axis_name), msg = "y_axis_name is not a character string.")
#   assertthat::assert_that(is.character(color_25_75), msg = "color_25_75 is not a character string.")
#   assertthat::assert_that(is.character(color_5_95), msg = "color_5_95 is not a character string.")
#   assertthat::assert_that(is.character(color_median), msg = "color_median is not a character string.")
#   assertthat::assert_that(color_25_75 %in% grDevices::colors(), 
#                           msg = "Please choose a color name for color_25_75 from the grDevices colors.")
#   assertthat::assert_that(color_5_95 %in% grDevices::colors(), 
#                           msg = "Please choose a color name for color_5_95 from the grDevices colors.")
#   assertthat::assert_that(color_median %in% grDevices::colors(), 
#                           msg = "Please choose a color name for color_median from the grDevices colors.")
#   assertthat::assert_that(any(substr(names(data), 1, nchar(cashflow_var_name)) %in% 
#                                 cashflow_var_name), msg = "There are no variables that start with the same name as cashflow_var_name in your data.")
#   if (any(is.na(data))) {
#     warning(paste("Some data included \"NA\" and", 
#                   table(is.na(data))[2], "rows were removed."))
#     data <- data[stats::complete.cases(data), ]
#   }
#   subset_data <- data %>% dplyr::select(dplyr::starts_with(cashflow_var_name)) %>% 
#     tidyr::pivot_longer(dplyr::starts_with(cashflow_var_name))
#   years_position <- stringr::str_locate(subset_data$name, pattern = "[:digit:]")
#   subset_data <- subset_data %>% dplyr::mutate(x_scale = as.numeric(substr(subset_data$name, 
#                                                                            years_position[, 1], years_position[, 2])), decision_option = as.character(substr(subset_data$name, 
#                                                                                                                                                              1, (years_position[, 1] - 1))))
#   
#   
#   
#   
#   subset_data$x_scale[subset_data$name == "Cashflow_decision_do10"] <- rep(10,100)
#   
#   
#   
#   
#   
#   summary_subset_data <- suppressMessages(subset_data %>% dplyr::group_by(decision_option, 
#                                                                           x_scale) %>% dplyr::summarize(p5 = quantile(value, 0.05), 
#                                                                                                         p25 = quantile(value, 0.25), p50 = quantile(value, 0.5), 
#                                                                                                         p75 = quantile(value, 0.75), p95 = quantile(value, 0.95)))
#   ggplot2::ggplot(summary_subset_data, ggplot2::aes(x_scale)) + 
#     ggplot2::geom_ribbon(ggplot2::aes(ymin = p5, ymax = p95, 
#                                       fill = legend_labels[1])) + ggplot2::geom_ribbon(ggplot2::aes(ymin = p25, 
#                                                                                                     ymax = p75, fill = legend_labels[2])) + ggplot2::geom_line(ggplot2::aes(y = p50, 
#                                                                                                                                                                             color = legend_labels[3])) + ggplot2::geom_line(ggplot2::aes(y = 0)) + 
#     ggplot2::scale_x_continuous(expand = c(0, 0)) + ggplot2::scale_y_continuous(labels = scales::comma) + 
#     ggplot2::scale_fill_manual(values = c(color_25_75, color_5_95)) + 
#     ggplot2::scale_color_manual(values = color_median) + 
#     ggplot2::guides(fill = ggplot2::guide_legend(reverse = T, 
#                                                  order = 1)) + ggplot2::labs(x = x_axis_name, y = y_axis_name, 
#                                                                              fill = legend_name, color = "") + ggplot2::facet_wrap(~factor(decision_option, 
#                                                                                                                                            labels = facet_labels)) + ggplot2::theme_bw(base_size = base_size) + 
#     ggplot2::theme(legend.margin = ggplot2::margin(-0.75, 
#                                                    0, 0, 0, unit = "cm"), strip.background = ggplot2::element_blank(), 
#                    ...)
# }
# 
# 
# 
# 
# 
# 
# cashflow_new <- plot_cashflow_new(mcSimulation_object = mcSimulation_results, cashflow_var_name = "Cashflow_decision_do")
# 
# ggsave(filename = "images/cashflow_new.png", plot = cashflow_new, width = 5, height = 3)
```





# Notes for improvement from the seminar 


**Inspiration from other presentations**  
  
  * Implement "interception" aspect at the base of the model  
* End model with "Overall value"/"NPV" instead of "Farmer's profit" 
* Add legend to the model visualisation  


**Suggestions to improve our model**  
  * Orchard size:
  + Keep applicability to many different situations in minds 
+ Create a number of realistic scenarios 
* Estimate maximum area one unit can work on $\Rightarrow$ Set maximum workload as upper boundary 
+ Consider max. speed, max. uninterrupted working hours 



## Example code from Seminar 08 and Seminar 09 

```{r, include = FALSE}
library(readr)
library(ggplot2)
library(plyr)
library(dplyr)
library(igraph)
```

## Seminar 08
Model Framework
* Runs for 10 years (Time to be financially feasible)
* One sprayer can handle 15 ha


Assigning model variables to variable type

* Event (`chance_event()`, simulate occurrence of random events), either happens or not
+ Governments concern triggers intervention, which results in the end of the model (less chance to occur for the automated one)
+ Disease infection, chance might be reduced with better biodiversity. Different severities.

* Fix variables
+ Cost of the machines are given (distribution)
+ Pesticides is a yearly necessity (distribution of mean over many years)

* Time-dependent variables (`vv()`, value varier function), variables that change with every iteration
+ Water contamination
+ Customers
+ Biodiversity (maybe using a logistic function?)
+ Fruit sales

* Combined variables
+ Both events are also time dependent, as higher water contamination rises goverments concern and thus an intervention
